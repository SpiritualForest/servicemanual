In this document I will try to explain some of the design choices I made for this application.

The design changed and evolved somewhat over the course of development.
The factors in this evolution and slight changes are that, first, I had never used Spring Boot prior to developing this application,
and second, I had never developed a REST API before this one.
So I had to learn to use Spring Boot as I was developing the application with it, and had to learn more in-depth about REST API principles at the same time.

In the controller, I decided to validate the POST and PUT request bodies with the @Valid annotation offered by javax.persistence.
This made validating the data and returning 400 "bad request" very easy.
However, at the same time, this came with trade-off: each request had to correspond exactly to the 
constraints placed on fields in the MaintenanceTask entity.
Certain fields are marked as NotNull, and the description is also marked as NotEmpty.

The ID and registration time fields are not constrained by NotNull or NotEmpty.
The ID doesn't need it because it is auto-generated by the database. We don't even touch it.

The registration time is a different case: it has no constraints.
I worked under the assumption that whenever a new task is added, the user expects its registration time to be right now,
the moment it was added. This means that I didn't want to force the user to explicitly pass 
a registration time in the request body. It would lead to bad UX.
MaintenanceTask's default constructor always sets the registration time to LocalDateTime.now().

I also operated under the assumption that nobody would realistically use this API by manually constructing the entire request via the command line.
In testing, I used curl sometimes to see responses and behaviour. But in reality, I highly doubt anybody would use it in this way.
I think that if this application was developed for a customer, they would expect a user interface, 
or some dedicated client, to be developed alongside it. So I developed a web front-end for that purpose as well.

So developing under these assumptions, I decided to keep the NotNull / NotEmpty constraints on most fields in the MaintenanceTask, 
because it's possible to make a front-end just send these fields along without touching them (when editing tasks).
This allowed me to leave the request body validation in the controller method to the framework (via @Valid annotation), and not have to worry about it.
All I had to do was configure the application to fail when a request body isn't valid.

The other option would be to manually validate the entire request each time. While this isn't really a problem,
it would by now require me to change the functionality of the application somewhat, 
and to perform null checks on every field that in the mapped object. I didn't want to do this. So I decided to leave it as is.
Manual null checks for everything is ugly.

As I learned more about REST API development and design, I changed my own API in subtle ways to conform better to the principles of REST.
This included using multiple methods on the same endpoint, with each method handling something else.
Initially I had a separate endpoint for creating new tasks, 
but later during development I decided to change it, in order to make the API more RESTful.

Before I learned more about how Spring Boot handles mappings and request parameters, 
I used overloaded methods for GET and DELETE mappings on /api/tasks in the controller.

Each overloaded method handled a different, fixed set of parameters.

This approach worked, until I discovered that it doesn't fail when encountering unknown parameters.
In testing, I accidentally deleted all the tasks from the database when passing unknown parameters.
I expected the request to fail and the response to be 400 "bad request", but the deletion took place.

That's when I decided to change the approach and validate all the query parameters myself, to prevent something like this from happening.

I developed the TaskFetcher (originally called QueryResolver) class to handle this problem.
The TaskFetcher accepts a map of string to string key/value pairs constituting the query parameters.
It iterates over the parameters and compares each one against the legal parameters that I've defined (deviceId, status, severity).
If the parameter is unknown, a QueryParameterException is thrown.

If a parameter is known, its value (data) is validated. If the validation fails, a QueryParameterException is thrown.

Each legal parameter has been assigned a numerical value. 1, 2, or 4.
If the validation succeeds, a databaseMethod integer has its value increased by the value that was assigned to the parameter (1, 2, or 4).

The value of databaseMethod tells us which parameters were found, and lets us decide what JPA repository method to use when fetching tasks.
For example if deviceId and severity were found, the value of databaseMethod becomes 5 (1+4, their combination).
So we know these two parameters exist, and we should call the repository function that filters by deviceId and severity, and pass those arguments along.

Prior to this parameter int value idea, I had a chain of if/else if/else checks that ensured the data is not null. This was bad, ugly, and not performant.

Using the TaskFetcher, I was able to get rid of the multiple GET and DELETE mappings in the controller, clean up the code significantly,
and increase its performance, due to moving away from manual null checks to constructing an integer value
and using switch/case against that value. Switch/case is better optimized for larger sets of data to compare values against, than if/else.
